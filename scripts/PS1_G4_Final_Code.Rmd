---
title: "Final code"
author: "Juan José Rojas, Francisco Soler, Jesús Yancy y Juan Otalora"
date: "2025-08-31"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r}
library(pacman)

p_load(rio, # Import/export data.
       tidyverse, # Tidy-data.
       stargazer, # Descriptive statistics.
       gt, # Descriptive statistics.
       gtsummary,
       caret, # For predictive model assessment.
       gridExtra, # Arrange plots.
       skimr, # Summarize data.
       here, #for file searching
       readr, #for opening files
       ggplot2,
       boot,
       scales,
       car,
       dplyr,
       tidyr
       )
```

# Database load and initial cleaning

```{r}
ruta <- here("stores", "data.csv")
db_base <- read_csv(ruta)
```

First, we drop all observations with ages \< 18.

```{r}
# Leave observations with age > 18
db_base <- db_base %>%
  filter(age >= 18)
# New database dimensions
dim(db_base)
# Number and proportion of minors
print((32177-24568)/32177)
```

We lost 23.6% of observations that corresponds to the number of minors,
leaving us with 24.568 individuals in the data.

# Understanding "employment" in the data

```{r}
# Create indicators of hours worked and labor salary income
db_base <- db_base %>%
  mutate(
    bin_ingLab_m     = ifelse(y_ingLab_m > 0, 1, 0),
    bin_ingLab_m_ha  = ifelse(y_ingLab_m_ha > 0, 1, 0),
    bin_hoursWorked  = ifelse(totalHoursWorked > 0, 1, 0),
    bin_ing_total  = ifelse(ingtot > 0, 1, 0),
  )
```

There's a huge tension between "income" and "wage". The "ocupados"
category do not only include what we could consider employed or
"empleados" stricly talking, but also self-employed and unpaid family
workers.

As the income of independent and self-employed individuals tends to be
more sensitive to external factors, while the wages of strictly employed
workers are generally more stable and primarily determined by their
individual characteristics and skills, we focus our analysis exclusively
on predicting the hourly wages of those who report receiving a salary
from employment.

```{r}
# Limit our sample to predict wages from labor
db_base <- db_base %>%
  filter(bin_ingLab_m_ha == 1)

```

# How much people work? 

Since the question on total hours worked is used to construct our main outcome variable—hourly wage—and it refers specifically to the number of hours worked in the week immediately prior to the survey, there may be random or external factors that atypically affect the reported figure. Respondents could, for example, report unusually high hours if they experienced an exceptional workload, or unusually low hours if they had an atypical break during that week. To avoid such outliers distorting our model, we first explore the distribution of reported hours and then filter extreme values accordingly.

```{r}
ggplot(db_base, aes(x = totalHoursWorked)) +
  # Histograma con densidad
  geom_histogram(aes(y = after_stat(density)),
                 bins = 50,
                 fill = "grey80",
                 color = "black",
                 alpha = 0.6) +
  # Línea de densidad suavizada
  geom_density(color = "black", linewidth = 1.0) +
  # Línea vertical en la media
  geom_vline(xintercept = mean(db_base$totalHoursWorked, na.rm = TRUE),
             linetype = "dashed",
             color = "grey35",
             linewidth = 0.6) +
  # Estética del gráfico
  scale_x_continuous(expand = expansion(mult = c(0.02, 0.02))) +
  scale_y_continuous(expand = expansion(mult = c(0.02, 0.06))) +
  labs(x = "Total Hours Worked",
       y = "Density") +
  theme_classic(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    axis.line  = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )

ggsave("distribution_total_hours.jpg", width = 8, height = 5)

hours_vars  <- c("totalHoursWorked", "hoursWorkUsual")
stargazer(as.data.frame(db_base[, hours_vars]), type = "text")

```
Lastly, in order to remove atypical cases were people were reporting
Total hours worked above the percentil 99 or below the percentil 1, we
removed those observation from the dataset.

```{r}

# Calcular percentiles 1 y 99
low <- quantile(db_base$totalHoursWorked, probs = 0.01, na.rm = TRUE)
up  <- quantile(db_base$totalHoursWorked, probs = 0.99, na.rm = TRUE)

# Etiquetar outliers
db_base <- db_base %>%
  mutate(out_totalHoursWorked = ifelse(totalHoursWorked < low | totalHoursWorked > up, 1, 0))

# Filtrar los outliers por separado (para conocer su comportamiento)
db_base_outliers <- db_base %>%
  filter(out_totalHoursWorked == 1)

# Filtrar los outliers de mi base final
db_base <- db_base %>%
  filter(out_totalHoursWorked == 0)

stargazer(as.data.frame(db_base[, hours_vars]), type = "text")
stargazer(as.data.frame(db_base[, hours_vars]), type = "text")

```

We got 9.700 people left on our study sample. A limited modelation like
this would allow us only to predict wages of people who already report
some income labor, so we could aim detect subreporting in tax fillings
of employed people, but no vulnerable people who could need assistance.

# Contructing relevant variables 

## Creating years of education

Lets start by constructing an approximation to the education level with
questions p6210 (which asks for the highest level of education attained)
and p6210s1 (which ask about years that were approved). We will count
only from elementary school (label p6210=3) to tertiary eduaction (label
p6210=6).

Pseudocode:

years of education: if p6210 = 1, 2, 9 then put 0 if p6210 = 3, 4, 5
then put the number of p6210s if p6210 = 6 then add the number of
p6210s + 11 (p.e p6210=6, p6210s1=5 then edu_years = 16)

```{r}
# We see the distribution on 
table(db_base$p6210s1[db_base$p6210 == 6])
table(db_base$p6210s1[db_base$p6210 == 4])

# Create years of education
db_base$edu_years <- ifelse(
  db_base$p6210 %in% c(1, 2, 9), 0,                   # None, Preschool, Unknown → 0
  ifelse(
    db_base$p6210 %in% c(3, 4, 5), db_base$p6210s1,        # Primary or Secondary → as is
    ifelse(db_base$p6210 == 6, db_base$p6210s1 + 11, NA)   # Tertiary → add 11
  )
)

edu_vars<-c("edu_years", "maxEducLevel", "p6210")
stargazer(as.data.frame(db_base[,edu_vars]), type="text")
```

## Creating Experience

Experience premium is a well-known phenomenon in labor economics. We
follow Fernandez and Messima (2018) to construct a potential experience
variable substracting `age-years of education-6`

```{r}
# Create experience var
db_base <- db_base %>%
  mutate(exp = age - edu_years - 6)
stargazer(as.data.frame(db_base[,"exp"]), type="text") # some people have negative experience (not possible)

sum(db_base$age < db_base$edu_years + 6, na.rm = TRUE)
inconsistent_age <- db_base %>%
  filter(age < edu_years + 6) %>%
  select(age, edu_years)  # There are not implausible cases, as some people could be early promoted (31 cases)
stargazer(as.data.frame(inconsistent_age[,"age"]), type="text") 
rm(inconsistent_age)

# We will impute 0 years to those 31 cases as most of them are around 21 years old
db_base$exp <- ifelse(db_base$exp < 0, 0, db_base$exp)
stargazer(as.data.frame(db_base[,"exp"]), type="text")
```

## Creating log of salary and saving
```{r}
# Creation of the Log salary
db_base <- db_base %>%
  mutate(Log_Total_hour_salary=log(db_base$y_ingLab_m_ha))

# Save few variables for better workflow
db = db_base |> select(Log_Total_hour_salary, ingtot, y_ingLab_m, y_salary_m, y_salarySec_m, y_ingLab_m_ha, y_salary_m_hu, y_salarySec_m_ha, totalHoursWorked, hoursWorkUsual, hoursWorkActualSecondJob, age, sex, estrato1, maxEducLevel, college, edu_years, exp, oficio, relab, formal, microEmpresa, regSalud, sizeFirm, p6240, ocu, dsi)

write.csv(db, "db_clean1.csv")

db <- db %>%
  mutate(across(
    c(formal, sizeFirm, relab, oficio),
    ~ as.factor(.)
  ))

```


# Exploring our variables of interest

First, we split our sample to explore characteristics by gender. 

```{r}
# We duplicate and split the base to explore data discriminated by gender
db_all   <- db_base
db_men   <- subset(db_base, sex==1)
db_women <- subset(db_base,  sex==0)
```

## Characterizing employment

```{r}
employment_vars  <- c("formal", "microEmpresa", "sizeFirm")

# Descriptive stats
stargazer(as.data.frame(db_all[, employment_vars]), type = "text")
stargazer(as.data.frame(db_men[, employment_vars]), type = "text")
stargazer(as.data.frame(db_women[, employment_vars]), type = "text")
```

Overall, about 77.6% of employment is formal, while 22.4% is informal, consistent with the predominance of formality in Bogotá’s labor market. Employment is also concentrated in larger firms: only 22% of jobs are in small businesses (≤5 employees), compared to nearly 78% in firms with more than five workers. The average firm size reported is 3.9 on a scale from 1 to 5, with a relatively wide dispersion (s.d. 1.3).

When disaggregating by sex, some differences emerge. Among men, 78.9% are formally employed, slightly higher than women’s 76.2%, suggesting that informality affects women somewhat more. Men are also less likely to work in small firms (18.5%) compared to women (25.5%). In line with this, the average firm size is higher for men (4.1) than for women (3.8), indicating that women’s employment is more concentrated in smaller organizations.

```{r}
# Employer type: 
cat("Overall", table(db_all$relab))
cat("% private (overall)", (8616/9700))
cat("Men", table(db_men$relab))
cat("% private (men)", (4574/4875))
cat("Women", table(db_women$relab))
cat("% private (women)", (4042/4825))
```

Most workers in the sample are private employees (88.9%), followed by government employees (5.7%) and domestic workers (5.5%), while agricultural day laborers are almost negligible. Among men, 93.8% are private employees, with very few in domestic work (0.4%). In contrast, women are more evenly split: 83.8% work as private employees, while a sizeable 10.6% are domestic workers, underscoring the strong gender segmentation in employment.Most workers in the sample are private employees (88.9%), followed by government employees (5.7%) and domestic workers (5.5%), while agricultural day laborers are almost negligible. Among men, 93.8% are private employees, with very few in domestic work (0.4%). In contrast, 83.8% of women work as private employees, while a sizeable 10.6% are domestic workers, underscoring the strong gender segmentation in this type of employment.

## Income, wages and hours worked

```{r}
# Variables of income
table(db_all$y)
work_vars <- c("y_ingLab_m", "y_ingLab_m_ha", "totalHoursWorked")
                 
# Explore statistics
base_theme <- theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 13, margin = margin(b = 6)),
    axis.title = element_text(size = 11),
    strip.text = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )

# Function to plot a set of variable
plot_variables <- function(db, vars, titulo = "Distribtion", bins = 30) {

  db_long <- db %>%
    dplyr::select(all_of(vars)) %>%
    pivot_longer(cols = everything(), names_to = "variable", values_to = "value") %>%
    filter(is.finite(value))
  
  # Histogram + Density
 p1 <- ggplot(db_long, aes(x = value)) +
    geom_histogram(aes(y = after_stat(density)),
                   bins = bins, fill = "steelblue", color = "white", alpha = 0.7) +
    geom_density(color = "darkred", linewidth = 0.4, na.rm = TRUE) +
    facet_wrap(~ variable, scales = "free", ncol = 2) +
    labs(
      title = paste(titulo, "- Histograms and Density"),
      x = "Value", y = "Density"
    ) +
    base_theme
  
  # Boxplots
  p2 <- ggplot(db_long, aes(x = variable, y = value)) +
    geom_boxplot(fill = "steelblue", outlier.color = "orange", width = 0.7) +
    coord_flip() +
    labs(
      title = paste(titulo, "- Boxplots"),
      x = "Variable", y = "Value"
    ) +
    base_theme

  list(histogramas = p1, boxplots = p2)
}

# Work characteristics
g_work <- plot_variables(db_all, work_vars, "Work variables")
print(g_work$histogramas)
print(g_work$boxplots)
stargazer(as.data.frame(db_all[, work_vars]), type = "text")
stargazer(as.data.frame(db_men[, work_vars]), type = "text")
stargazer(as.data.frame(db_women[, work_vars]), type = "text")
```

# Characteristics of individuals

## Exploring characteristics

```{r}
dem_vars <- c("age" ,"exp", "estrato1", "maxEducLevel", "edu_years")
                 
g_dem <- plot_variables(db_all, dem_vars, "Demographics")
print(g_dem$histogramas)
print(g_dem$boxplots)
stargazer(as.data.frame(db_all[,dem_vars]), type="text") 
stargazer(as.data.frame(db_men[,dem_vars]), type="text") 
stargazer(as.data.frame(db_women[,dem_vars]), type="text") 
```

## 3. Age-wage profile

A great deal of evidence in labor economics suggests that the typical
worker’s age-wage profile has a predictable path: “Wages tend to be low
when the worker is young; they rise as the worker ages, peaking at about
age 50; and the wage rate tends to remain stable or decline slightly
after age 50”.

In this subsection we are going to estimate the Age-wage profile profile
for the individuals in this sample:

$$ log(w) = β_1 + β_2Age+ β_3Age^2 + u $$

```{r}
db <- db %>%
  mutate(age2 = age^2)
```

```{r}
model_age <- lm(Log_Total_hour_salary ~ age + age2, data = db)

stargazer(model_age, type = "text")
```

### Interpretación

$\beta_2>0$ y $\beta_3<0$ confirman una trayectoria
cóncava:$\partial\ln w/\partial \text{age}=\beta_2+2\beta_3\text{age}$
es positiva a edades tempranas y decrece con la edad.

La estimación del perfil edad–salario muestra un coeficiente positivo
para la edad (0.069) y un coeficiente negativo para la edad al cuadrado
(-0.001), ambos estadísticamente significativos al 1%. Esto implica que
los salarios horarios aumentan con la edad, pero a un ritmo decreciente,
confirmando la forma cóncava predicha por la teoría de capital humano.

### Ajuste en muestra

El $R^2=0.047$ es esperable en este tipo de estimaciones: la variación
no explicada suele residir en educación, ocupación, sector, horas y
otros controles no modelados. Que el ajuste sea bajo no invalida el
hallazgo central sobre la forma del perfil (Mincer, 1974).

## Peak age

```{r}
# Extraer coeficientes
coefs <- coef(model_age)
b2 <- coefs["age"]
b3 <- coefs["age2"]

peak_age <- -b2 / (2 * b3)
peak_age

peak_salary <- coefs["(Intercept)"] + b2*peak_age + b3*peak_age^2
exp(peak_salary)

```

La edad que maximiza el salario esperado es

$age^*=-\frac{\hat\beta_2}{2\hat\beta_3}=\mathbf{45.2}\ \text{años}.$

Para la muestra original, la edad del máximo es 45.2 años y, a partir de
un bootstrap no paramétrico con 1,000 réplicas, obtenemos el intervalo
percentil 95% $[44.07,\ 46.65]$. Esto sitúa el pico de salario por hora
de manera estadísticamente precisa en la segunda mitad de los 40s,
coherente con la acumulación temprana de capital humano y retornos
decrecientes conforme aumentan los años. La Figura x (perfil estimado)
muestra la pendiente positiva inicial, el aplanamiento alrededor del
pico y una ligera caída posterior, tal como documentan los perfiles
edad–salario clásicos.

```{r}
# GRÁFICA
peak_logw <- peak_salary
peak_salary_lvl <- exp(peak_logw)
peak_salary_lab <- format(peak_salary_lvl, big.mark = ",", decimal.mark = ".", scientific = FALSE, trim = TRUE)

age_min <- 18
age_max <- ceiling(max(db$age, na.rm = TRUE))
age_seq <- seq(age_min, age_max, length.out = 400)
newdat  <- data.frame(age = age_seq, age2 = age_seq^2)

pred <- predict(model_age, newdata = newdat, se.fit = TRUE)
crit <- qnorm(0.975)
plot_data <- data.frame(
  age = age_seq,
  fit = exp(pred$fit),
  lwr = exp(pred$fit - crit*pred$se.fit),
  upr = exp(pred$fit + crit*pred$se.fit)
)

label_text <- "Age: 45.2 years\nWage: $7,248 hourly"
label_x    <- peak_age
label_y    <- peak_salary_lvl + 0.04*diff(range(plot_data$fit, na.rm = TRUE))

p <- ggplot(plot_data, aes(x = age, y = fit)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), fill = "grey80", alpha = 0.35, colour = NA) +
  geom_line(color = "black", linewidth = 1.0) +
  geom_vline(xintercept = peak_age, linetype = "dashed", color = "grey35", linewidth = 0.6) +
  annotate("point", x = peak_age, y = peak_salary_lvl,
           shape = 21, size = 2.8, stroke = 0.7, fill = "white", color = "black") +
  annotate("label", x = label_x, y = label_y, label = label_text,
           label.size = 0, fill = "white", size = 3.2, hjust = 0) +
  scale_x_continuous(limits = c(age_min, age_max), breaks = seq(18, age_max, by = 4)) +
  scale_y_continuous(expand = expansion(mult = c(0.02, 0.06))) +
  labs(title = "Age-Wage Profile",
       x = "Age", y = "Hourly Wage (Levels)") +
  theme_classic(base_size = 11) +
  theme(plot.title = element_text(face = "bold"),
        axis.title = element_text(face = "bold"),
        axis.line  = element_line(color = "black"),
        axis.ticks = element_line(color = "black"))
p

```

## Calcular los intervalos de confianza del peak age con bootstrap

```{r}
# Se define la función que recibe los datos y un vector de índices que boot genera en cada subset de la muestra con reemplazo.
# La función devuelve el peak age para cada subset.
peak_fn <- function(data, index) {
  fit <- lm(Log_Total_hour_salary ~ age + age2, data = data, subset = index) # Estima el modelo con cada subset
  coefs <- coef(fit)
  -coefs["age"] / (2 * coefs["age2"]) # Calcular el peak age de cada subset
}

# Se prueba en la muestra original
peak_fn(db, 1:nrow(db))

# bootstrap con 1000 réplicas
set.seed(123)
boot_out <- boot(db, statistic = peak_fn, R = 1000)

# resultados
boot_out$t0          # peak age de la muestra original
boot_out             # resumen del bootstrap

# intervalos de confianza
boot.ci(boot_out, type = "perc")
```

Nota metodológica (bootstrap). El intervalo se construyó con el método
percentil, re-muestreando individuos con reemplazo, re-estimando
$\hat age^$ en cada réplica y leyendo los cuantiles 2.5% y 97.5%.

# 4. Equal pay for equal job

## Unconditional Gender-Wage GAP

$$ log(w) = β_1 + β_2Female + u $$

```{r}
# Create indicator of female

db <- db %>%
  mutate(bin_female = 1 - sex)

db$bin_female <- as.factor(db$bin_female)

class(db$bin_female)

# Run the model 
model_sex <- lm(Log_Total_hour_salary ~ bin_female, data = db)

# View the coefficients
stargazer(model_sex, type = "text")

```

The unconditional regression indicates that women earn, on average,
about 4.7 percent less per hour than men. This gap is estimated without
controlling for any observable characteristics, so it reflects the raw
difference in average hourly wages between the two groups. In other
words, the coefficient captures the unconditional gender wage gap in
log-wage terms.

# Equal Pay for Equal Work?

We need to control for: - Similar worker characteristics: Education (edu
years, max level, college), age or experience.

-   Similar job nature characteristics: formality (formal), size of the
    business (sizeFirm), Public-private sector (relab)

-   Similar job role characteristics: occupation (oficio)

$$ log(w) = \beta_1 + \beta_2Female + \beta_3Education + \beta_4Age + \beta_5Age^2 + \beta_5Formality + \beta_6Business Size + \gamma_1Oficio + u $$

$$ log(w) = \beta_1 + \beta_2Female + \beta_3Education + \beta_4Experience + \beta_5Age^2 + \beta_5 + u $$

```{r}
  
# Individual characteristics (edu_years + age + age2)
model_equality1 <- lm(Log_Total_hour_salary ~ bin_female + edu_years + age + age2, data = db)

# Individual + Firm nature
model_equality2 <- lm(Log_Total_hour_salary ~ bin_female + edu_years + age + age2 + formal +  sizeFirm + relab, data = db)

# Individual + Firm nature + occupation
model_equality3 <- lm(Log_Total_hour_salary ~ bin_female + edu_years + age + age2 + formal +  sizeFirm + relab + oficio, data = db)

# View the coefficients
stargazer(model_sex, model_equality1, model_equality2, model_equality3, type = "text", digits=7 ,out = "tabla_modelo.txt")

```

```{r}
db %>%
  mutate(sex = factor(sex, levels = c(1,0), labels = c("Men","Women"))) %>%
  select(sex, edu_years, Log_Total_hour_salary, age) %>%
  tbl_summary(by = sex,
              statistic = all_continuous() ~ "{mean} ({sd})",
              digits = all_continuous() ~ 2) %>%
  add_n() %>%           # agrega N por grupo
  add_p()               # prueba de diferencia

```

```{R}

db$bin_female <- as.numeric(as.character(db$bin_female))
db$Log_Total_hour_salary <- as.numeric(as.character(db$Log_Total_hour_salary))

#Running the model with FWL to check same results as the above estimations (Model 1)
# Individual

db<-db %>% mutate(FemaleResidX=lm(bin_female~edu_years + age + age2,data = db)$residuals) #Residuals of weight~foreign 

db<-db %>% mutate(LogSalResidX=lm(Log_Total_hour_salary~edu_years + age + age2,data = db)$residuals) #Residuals of mpg~foreign 

model_equality1_FWL<-lm(LogSalResidX~FemaleResidX,db)


#Running the model with FWL to check same results as the above estimations (Model 2)
# Individual  + Firm nature

db<-db %>% mutate(Female2ResidX=lm(bin_female~edu_years + age + age2 + formal +  sizeFirm + relab ,data = db)$residuals) #Residuals of weight~foreign 

db<-db %>% mutate(LogSal2ResidX=lm(Log_Total_hour_salary~edu_years + age + age2 + formal +  sizeFirm + relab,data = db)$residuals) #Residuals of mpg~foreign 

model_equality2_FWL<-lm(LogSal2ResidX~Female2ResidX,db)


#Running the model with FWL to check same results as the above estimations (Model 3)
# Individual + Firm nature + occupation

db<-db %>% mutate(Female3ResidX=lm(bin_female~edu_years + age + age2 + formal +  sizeFirm + relab + oficio,data = db)$residuals) #Residuals of weight~foreign 

db<-db %>% mutate(LogSal3ResidX=lm(Log_Total_hour_salary~edu_years + age + age2 + formal +  sizeFirm + relab + oficio,data = db)$residuals) #Residuals of mpg~foreign 

model_equality3_FWL<-lm(LogSal3ResidX~Female3ResidX,db)




stargazer(model_sex, model_equality1_FWL, model_equality2_FWL, model_equality3_FWL, type="text",digits=7)


#Dado que nos vamos a quedar con 3, corrijo el error estandar, dado que R, no reconoce el numero real de estimadores implicados en FWL:
n <- nrow(db)
# Número de parámetros en el modelo completo (incluye intercepto)
k <- length(coef(model_equality3))
# Varianza-covarianza del modelo FWL
vcov_fwl <- vcov(model_equality3_FWL)
# Corrección por grados de libertad
vcov_fwl_corrected <- vcov_fwl * ((n - 1) / (n - k))
# Error estándar corregido
se_corrected <- sqrt(diag(vcov_fwl_corrected))
se_corrected





```

```{R}

#Sacamos los errores estandar con Bootstrap

boot_fwl <- function(data, indices) {
  db <- data[indices, ]
  LogSalBootResidX <- resid(lm(Log_Total_hour_salary~edu_years + age + age2 + formal +  sizeFirm + relab + oficio,data = db))
  FemaleBootResidX <- resid(lm(bin_female~edu_years + age + age2 + formal +  sizeFirm + relab + oficio,data = db))
  coef(lm(LogSalBootResidX ~ FemaleBootResidX ))[2]
}

boot_fwl(db,1:nrow(db))

set.seed(10101)
results <- boot(db, boot_fwl, R = 1000)
results
boot.ci(results, type = "perc")


```

```{R}
# Perfiles y Picos por Género (Edad) modelo con controles
db$bin_female <- as.factor(as.character(db$bin_female))

model_equality3interaction <- lm(Log_Total_hour_salary ~ bin_female + age + age2 + age*bin_female + age2*bin_female + edu_years + formal +  sizeFirm + relab + oficio, data = db)

# Picos por género
fit <- model_equality3interaction

co <- coef(fit)
nm <- names(co)

#Busca el nombre correcto entre varias variantes
pick1 <- function(cands) {
  hit <- intersect(cands, nm)
  if (length(hit) != 1) stop("No se identificó de forma única: ", paste(cands, collapse=", "))
  unname(co[hit])
}

# β2 (age) y β3 (age^2 o I(age^2))
b2 <- pick1(c("age"))
b3 <- pick1(c("age2", "I(age^2)"))

# δ2 (interacción lineal) y δ3 (interacción cuadrática)
d2 <- pick1(c("age:bin_female","bin_female:age","age:bin_female1","bin_female1:age"))
d3 <- pick1(c("age2:bin_female","bin_female:age2",
              "I(age^2):bin_female","bin_female:I(age^2)",
              "age2:bin_female1","bin_female1:age2",
              "I(age^2):bin_female1","bin_female1:I(age^2)"))

# Picos
a_H <- - b2 / (2*b3)
a_M <- - (b2 + d2) / (2*(b3 + d3))

c(peak_men = a_H, peak_women = a_M)
```

```{R}
#Determinacion de la diferencia estadistica de los picos
# Error estándar del pico hombres
Deltamale=deltaMethod(fit, "-age / (2 * age2)")
Deltamale
SEmale=as.numeric(Deltamale[2])

# Error estándar del pico mujeres
Deltafemale=deltaMethod(fit, "-(age + `bin_female1:age`) / (2 * (age2 + `bin_female1:age2`))")

SEfemale=as.numeric(Deltafemale[2])


# Diferencia de picos
diff_peaks <- a_H - a_M
diff_peaks

# Error estándar de la diferencia
se_diff <- sqrt(SEmale^2 + SEfemale^2)
se_diff

# Estadístico t
t_stat <- diff_peaks / se_diff
t_stat

p_value <- 2 * pt(-abs(t_stat), df = df.residual(fit))
p_value

```

```{r}
# Gráfica

fit <- model_equality3interaction
mf  <- model.frame(fit)

# Rango y grid
age_min <- max(18, floor(min(mf$age, na.rm=TRUE)))
age_max <- ceiling(max(mf$age, na.rm=TRUE))
ages    <- seq(age_min, age_max, length.out = 300)

# Fila de referencia (medias/moda)
most_common <- function(x) names(sort(table(x), decreasing=TRUE))[1]
ref_row <- as.data.frame(lapply(mf, function(x)
  if (is.numeric(x)) mean(x, na.rm=TRUE) else factor(most_common(x), levels=levels(x))
))[1,,drop=FALSE]

# Grids por sexo (factor 2 niveles o 0/1)
if (is.factor(mf$bin_female)) { lev <- levels(mf$bin_female); male <- lev[1]; female <- lev[2]
  make_grid <- function(sex) { nd <- ref_row[rep(1, length(ages)),,drop=FALSE]
    nd$age <- ages; if ("age2"%in%names(nd)) nd$age2 <- ages^2
    nd$bin_female <- factor(sex, levels=lev); nd }
} else { male <- 0; female <- 1
  make_grid <- function(sex) { nd <- ref_row[rep(1, length(ages)),,drop=FALSE]
    nd$age <- ages; if ("age2"%in%names(nd)) nd$age2 <- ages^2
    nd$bin_female <- sex; nd }
}
grid_m <- make_grid(male); grid_f <- make_grid(female)

# Predicciones (log) -> niveles + IC 95%
crit <- qnorm(0.975)
to_levels <- function(pr) data.frame(fit=exp(pr$fit),
                                     lwr=exp(pr$fit-crit*pr$se.fit),
                                     upr=exp(pr$fit+crit*pr$se.fit))
pm <- predict(fit, newdata=grid_m, se.fit=TRUE)
pf <- predict(fit, newdata=grid_f, se.fit=TRUE)
plot_data <- rbind(
  cbind(age=ages, to_levels(pm), group="Hombres"),
  cbind(age=ages, to_levels(pf), group="Mujeres")
)

# Picos (con interacciones)
co <- coef(fit); nm <- names(co)
b2 <- unname(co["age"])
b3 <- unname(co[intersect(c("age2","I(age^2)"), nm)][1])
d2 <- unname(co[intersect(c("age:bin_female","bin_female:age","age:bin_female1","bin_female1:age"), nm)][1])
d3 <- unname(co[intersect(c("age2:bin_female","bin_female:age2","I(age^2):bin_female","bin_female:I(age^2)",
                            "age2:bin_female1","bin_female1:age2","I(age^2):bin_female1","bin_female1:I(age^2)"), nm)][1])
v_m <- max(age_min, min(age_max, - b2/(2*b3)))
v_f <- max(age_min, min(age_max, - (b2 + d2)/(2*(b3 + d3))))

# Puntos crudos en niveles, color por sexo (sin afectar eje-Y)
db_pts <- transform(
  db,
  group = if (is.factor(bin_female)) factor(bin_female, labels=c("Hombres","Mujeres"))
          else factor(bin_female, levels=c(0,1), labels=c("Hombres","Mujeres")),
  wage  = exp(Log_Total_hour_salary)
)

# Tope del eje-Y tomado de las curvas (no de los puntos)
y_cap <- max(quantile(plot_data$upr, 0.999, na.rm=TRUE)) * 1.2

# grafico
cols <- c("Hombres"="#274C77","Mujeres"="#EF6351")
p <- ggplot(plot_data, aes(age, fit, color=group, linetype=group)) +
  geom_ribbon(aes(ymin=lwr, ymax=upr, fill=group), alpha=0.20, colour=NA, show.legend=FALSE) +
  geom_point(data=db_pts, aes(age, wage, color=group),
             alpha=0.5, size=0.7, stroke=0.4, inherit.aes=FALSE,
             position=position_jitter(width=0.25, height=0), na.rm=TRUE) +
  geom_line(linewidth=1.2) +
  geom_vline(xintercept=v_m, linetype="dashed", color=cols["Hombres"], show.legend=FALSE) +
  geom_vline(xintercept=v_f, linetype="dashed", color=cols["Mujeres"],  show.legend=FALSE) +
  coord_cartesian(ylim=c(0, y_cap)) +
  scale_color_manual(NULL, values=cols) +
  scale_fill_manual(NULL,  values=cols) +
  scale_linetype_manual(NULL, values=c("Hombres"="solid","Mujeres"="solid")) +
  scale_y_continuous(labels=label_number(big.mark=",")) +
  labs(title="Age-Wage Profile by sex (Fit with controls)",
       x="Age", y="Hourly Wage (Levels)") +
  theme_classic(base_size=12) +
  theme(plot.title=element_text(face="bold"),
        axis.title=element_text(face="bold"),
        legend.position="top")

p

ggsave("perfil_edad_salario_controles.jpg", plot = p,
       width = 8, height = 4.4,
       dpi = 600)

```

```{r}

# IC with bootstrap
peak_fn <- function(data, index) {
  d <- data[index, , drop = FALSE]

  # Asegura levels consistentes en cada réplica
  if (!is.factor(d$bin_female)) d$bin_female <- factor(d$bin_female, levels = c(0,1))

  fit <- lm(Log_Total_hour_salary ~ bin_female + age + age2 +
              age*bin_female + age2*bin_female +
              edu_years + formal + sizeFirm + relab + oficio,
            data = d)

  co <- coef(fit); nm <- names(co)

  pick1 <- function(cands) {
    hit <- intersect(cands, nm)
    if (length(hit) < 1) stop("No se encontró coef para: ", paste(cands, collapse=", "))
    unname(co[hit[1]])
  }

  # β2 y β3
  b2 <- pick1(c("age"))
  b3 <- pick1(c("age2", "I(age^2)"))

  # δ2 y δ3
  d2 <- pick1(c("age:bin_female","bin_female:age","age:bin_female1","bin_female1:age"))
  d3 <- pick1(c("age2:bin_female","bin_female:age2",
                "I(age^2):bin_female","bin_female:I(age^2)",
                "age2:bin_female1","bin_female1:age2",
                "I(age^2):bin_female1","bin_female1:I(age^2)"))

  a_H <- - b2 / (2*b3)
  a_M <- - (b2 + d2) / (2*(b3 + d3))

  c(peak_men = a_H, peak_women = a_M)   # <-- devolver ambos
}

# Prueba en muestra original
peak_fn(db, 1:nrow(db))

# Bootstrap
set.seed(123)
boot_out <- boot(db, statistic = peak_fn, R = 1000)

# Resultados
boot_out$t0                        # c(peak_men, peak_women)
boot.ci(boot_out, type = "perc", index = 1)  # IC hombres
boot.ci(boot_out, type = "perc", index = 2)  # IC mujeres
```

```{r}
# Perfiles y Picos por Género (Edad) modelo SIN controles

model_edad_sex <- lm(Log_Total_hour_salary ~ bin_female + age + age2 + age*bin_female + age2*bin_female, data = db)

# Picos por género
fit12 <- model_edad_sex

co12 <- coef(fit12)
nm12 <- names(co12)

#Buscar el nombre correcto entre varias variantes
pick12 <- function(cands12) {
  hit12 <- intersect(cands12, nm12)
  if (length(hit12) != 1) stop("No se identificó de forma única: ", paste(cands12, collapse=", "))
  unname(co12[hit12])
}

# β2 (age) y β3 (age^2 o I(age^2))
b212 <- pick12(c("age"))
b312 <- pick12(c("age2", "I(age^2)"))

# δ2 (interacción lineal) y δ3 (interacción cuadrática)
d212 <- pick12(c("age:bin_female","bin_female:age","age:bin_female1","bin_female1:age"))
d312 <- pick12(c("age2:bin_female","bin_female:age2",
              "I(age^2):bin_female","bin_female:I(age^2)",
              "age2:bin_female1","bin_female1:age2",
              "I(age^2):bin_female1","bin_female1:I(age^2)"))

# Picos
a_H12 <- - b212 / (2*b312)
a_M12 <- - (b212 + d212) / (2*(b312 + d312))

c(peak_men12 = a_H12, peak_women12 = a_M12)

```

```{r}
# Modelo sin controles
fit <- model_edad_sex
mf  <- model.frame(fit)

# Rango y grid
age_min <- max(18, floor(min(mf$age, na.rm = TRUE)))
age_max <- ceiling(max(mf$age, na.rm = TRUE))
ages    <- seq(age_min, age_max, length.out = 300)

# Fila de referencia (medias/moda)
most_common <- function(x) names(sort(table(x), decreasing = TRUE))[1]
ref_row <- as.data.frame(lapply(mf, function(x)
  if (is.numeric(x)) mean(x, na.rm = TRUE) else factor(most_common(x), levels = levels(x))
))[1, , drop = FALSE]

# Grids por sexo (factor con 2 niveles o 0/1)
if (is.factor(mf$bin_female)) {
  lev <- levels(mf$bin_female); male <- lev[1]; female <- lev[2]
  make_grid <- function(sex) {
    nd <- ref_row[rep(1, length(ages)), , drop = FALSE]
    nd$age <- ages; if ("age2" %in% names(nd)) nd$age2 <- ages^2
    nd$bin_female <- factor(sex, levels = lev); nd
  }
} else {
  male <- 0; female <- 1
  make_grid <- function(sex) {
    nd <- ref_row[rep(1, length(ages)), , drop = FALSE]
    nd$age <- ages; if ("age2" %in% names(nd)) nd$age2 <- ages^2
    nd$bin_female <- sex; nd
  }
}
grid_m <- make_grid(male)
grid_f <- make_grid(female)

# predict
crit <- qnorm(0.975)
to_levels <- function(pr) data.frame(
  fit = exp(pr$fit),
  lwr = exp(pr$fit - crit*pr$se.fit),
  upr = exp(pr$fit + crit*pr$se.fit)
)
pm <- predict(fit, newdata = grid_m, se.fit = TRUE)
pf <- predict(fit, newdata = grid_f, se.fit = TRUE)
plot_data <- rbind(
  cbind(age = ages, to_levels(pm), group = "Hombres"),
  cbind(age = ages, to_levels(pf), group = "Mujeres")
)

# Picos
co <- coef(fit); nm <- names(co)
b2 <- unname(co["age"])
b3 <- unname(co[intersect(c("age2","I(age^2)"), nm)][1])
d2 <- unname(co[intersect(c("age:bin_female","bin_female:age","age:bin_female1","bin_female1:age"), nm)][1])
d3 <- unname(co[intersect(c("age2:bin_female","bin_female:age2",
                            "I(age^2):bin_female","bin_female:I(age^2)",
                            "age2:bin_female1","bin_female1:age2",
                            "I(age^2):bin_female1","bin_female1:I(age^2)"), nm)][1])
v_m <- max(age_min, min(age_max, - b2/(2*b3)))
v_f <- max(age_min, min(age_max, - (b2 + d2)/(2*(b3 + d3))))

# Puntos crudos en niveles, color por sexo
db_pts <- transform(
  db,
  group = if (is.factor(bin_female)) factor(bin_female, labels = c("Hombres","Mujeres"))
          else factor(bin_female, levels = c(0,1), labels = c("Hombres","Mujeres")),
  wage  = exp(Log_Total_hour_salary)
)

# Tope del eje-Y basado en las curvas (no los puntos)
y_cap <- max(quantile(plot_data$upr, 0.999, na.rm = TRUE)) * 1.02

# grafico
cols <- c("Hombres"="#274C77","Mujeres"="#EF6351")
p2 <- ggplot(plot_data, aes(age, fit, color = group)) +  # líneas sólidas para ambos
  geom_ribbon(aes(ymin = lwr, ymax = upr, fill = group),
              alpha = 0.20, colour = NA, show.legend = FALSE) +
  geom_point(data = db_pts, aes(age, wage, color = group),
             alpha = 0.5, size = 0.7, stroke = 0.4, inherit.aes = FALSE,
             position = position_jitter(width = 0.25, height = 0), na.rm = TRUE) +
  geom_line(linewidth = 1.2) +
  geom_vline(xintercept = v_m, linetype = "dashed", color = cols["Hombres"], show.legend = FALSE) +
  geom_vline(xintercept = v_f, linetype = "dashed", color = cols["Mujeres"],  show.legend = FALSE) +
  coord_cartesian(ylim = c(0, y_cap)) +
  scale_color_manual(NULL, values = cols) +
  scale_fill_manual(NULL,  values = cols) +
  scale_y_continuous(labels = scales::label_number(big.mark = ",")) +
  labs(title = "Age–Wage Profile by Sex (No controls)",
       x = "Age", y = "Hourly Wage (levels)") +
  theme_classic(base_size = 12) +
  theme(plot.title = element_text(face = "bold"),
        axis.title  = element_text(face = "bold"),
        legend.position = "top")
p2

ggsave("perfil_edad_salario_nocontroles.jpg", plot = p2,
       width = 8, height = 4.4,
       dpi = 600)
```

```{r}
# Bootstrap (sin controles)
peak_fns <- function(data, index) {
  d <- data[index, , drop = FALSE]
  if (!is.factor(d$bin_female)) d$bin_female <- factor(d$bin_female, levels = c(0,1))

  fit <- lm(
    Log_Total_hour_salary ~ bin_female + age + age2 +
      age*bin_female + age2*bin_female,
    data = d
  )

  co <- coef(fit); nm <- names(co)
  pick1 <- function(cands) { h <- intersect(cands, nm); if (!length(h)) stop("faltan: ", paste(cands, collapse=", ")); unname(co[h[1]]) }

  b2 <- pick1(c("age"))
  b3 <- pick1(c("age2","I(age^2)"))
  d2 <- pick1(c("age:bin_female","bin_female:age","age:bin_female1","bin_female1:age"))
  d3 <- pick1(c("age2:bin_female","bin_female:age2",
                "I(age^2):bin_female","bin_female:I(age^2)",
                "age2:bin_female1","bin_female1:age2",
                "I(age^2):bin_female1","bin_female1:I(age^2)"))

  c(peak_men   = - b2/(2*b3),
    peak_women = - (b2 + d2)/(2*(b3 + d3)))
}

# Prueba en muestra original
peak_fns(db, 1:nrow(db))

set.seed(123)
boot_outs <- boot(db, statistic = peak_fns, R = 1000)

boot_outs$t0
boot.ci(boot_outs, type = "perc",  index = 1)  # IC hombres
boot.ci(boot_outs, type = "perc",  index = 2)  # IC mujeres
```

##5. Prediction

```{r}
#Data cleaning for this point
db <- db %>%
  mutate(
    exp2 = exp^2,
    maxEducLevel = as.factor(if_else(is.na(maxEducLevel), 1, maxEducLevel)),
    relab = as.factor(if_else(relab == "8", "3", relab))
  )

class(db$maxEducLevel)
  
```

```{r}

# split 70/30
set.seed(10101)
inTrain <- createDataPartition(y = db$Log_Total_hour_salary, p = 0.7, list = FALSE)



# Train y test
train <- db[inTrain, ]
test  <- db[-inTrain, ]


missing_levels <- setdiff(levels(factor(db$oficio)), levels(factor(train$oficio)))

#Code to guarantee all levels in oficio in the training model
for (lvl in missing_levels) {
  row_to_move <- test[test$oficio == lvl, ][1, ]
  train <- rbind(train, row_to_move)
  test <- test[!(rownames(test) %in% rownames(row_to_move)), ]
}


#Check distribution 
c(n_train = nrow(train), n_test = nrow(test), prop_train = nrow(train)/nrow(db))
```

```{r}
# Control: k-fold CV
ctrl <- trainControl(
  method = "CV" , # Method for resampling. It could be CV, repeated CV, LOOCV, and so on. 
  number = 10     # 10 folds
)
```

### Basic Regression

```{r}
# Perfil edad-salario (edad + edad^2)
form_B0 <- Log_Total_hour_salary ~ age + age2

# female
form_B1 <- Log_Total_hour_salary ~ bin_female

# female + controles
form_B2 <- Log_Total_hour_salary ~ bin_female + edu_years + age + age2 + formal +  sizeFirm + relab + oficio
```

### Additional Regresions

```{r}
#Nuevo modelo con variable proxy de experiencia en lugar de años de educación
form_M1 <- Log_Total_hour_salary ~ bin_female + age + age2 + maxEducLevel + exp + exp2+ formal + sizeFirm + relab + oficio

#Una mejora de nuestro modelo, incluyendole poly a age y estrato
form_A2 <- Log_Total_hour_salary ~ bin_female + edu_years + poly(age, 4, raw=TRUE) + formal + sizeFirm + relab + oficio + estrato1

#Modelo que busca predecir mediante las relaciones entre la edad y distintas variables de la persona y su conocimiento
form_A3 <- Log_Total_hour_salary ~ bin_female + edu_years + age + age2 + age*bin_female + age2*bin_female + age*edu_years

#Un modelo con un montón de variables y exponenciales
form_A4 <- Log_Total_hour_salary ~ poly(age, 4, raw=TRUE) + bin_female + poly(exp,5,raw=TRUE) + edu_years + formal + sizeFirm + relab + estrato1 + college + age*bin_female + age2*bin_female

#Un modelo centrado solamente en características del empleo y la experiencia de la persona
form_A5 <- Log_Total_hour_salary ~ poly(exp, 7, raw=TRUE) + oficio + oficio*exp

```

```{r}
set.seed(10101)
modelo_B0 <- lm(form_B0,
              data = train)
predictions_modelo_B0 <- predict(modelo_B0, test)
score_modelo_B0<- RMSE(predictions_modelo_B0, test$Log_Total_hour_salary )
```

```{r}
set.seed(10101)
modelo_B1 <- lm(form_B1,
              data = train)
predictions_modelo_B1 <- predict(modelo_B1, test)
score_modelo_B1<- RMSE(predictions_modelo_B1, test$Log_Total_hour_salary )
```

```{r}
set.seed(10101)
modelo_B2 <- lm(form_B2,
              data = train)
predictions_modelo_B2 <- predict(modelo_B2, test)
score_modelo_B2<- RMSE(predictions_modelo_B2, test$Log_Total_hour_salary )

```

```{r}
set.seed(10101)
modelo_A1 <- lm(form_A1,
              data = train)
predictions_modelo_A1 <- predict(modelo_A1, test)
score_modelo_A1<- RMSE(predictions_modelo_A1, test$Log_Total_hour_salary )
```

```{r}
set.seed(10101)
modelo_A2 <- lm(form_A2,
              data = train)
predictions_modelo_A2 <- predict(modelo_A2, test)
score_modelo_A2<- RMSE(predictions_modelo_A2, test$Log_Total_hour_salary )
```

```{r}
set.seed(10101)
modelo_A3 <- lm(form_A3,
              data = train)
predictions_modelo_A3 <- predict(modelo_A3, test)
score_modelo_A3<- RMSE(predictions_modelo_A3, test$Log_Total_hour_salary )
```


```{r}
set.seed(10101)
modelo_A4 <- lm(form_A4,
              data = train)
predictions_modelo_A4 <- predict(modelo_A4, test)
score_modelo_A4<- RMSE(predictions_modelo_A4, test$Log_Total_hour_salary )
```

```{r}
set.seed(10101)
modelo_A5 <- lm(form_A5,
              data = train)
predictions_modelo_A5 <- predict(modelo_A5, test)
score_modelo_A5<- RMSE(predictions_modelo_A5, test$Log_Total_hour_salary )
```

```{r}

tabla_modelos <- data.frame(
  Modelo = c("B0_age2","B1_female","B2_female_ctrl",
                "A1","A2","A3","A4","A5"),
  RMSE_VS = c(score_modelo_B0, score_modelo_B1, score_modelo_B2, score_modelo_A1, score_modelo_A2, score_modelo_A3,   score_modelo_A4, score_modelo_A5))

# Ordena por desempeño en test (menor RMSE es mejor)
tabla_modelos <- tabla_modelos[order(tabla_modelos$RMSE_VS), ]
tabla_modelos

```
La estimación con el menor RMSE fue la especificación adicional #2, seguida por la #1

```{r}

# Ajuste del modelo
A2VS <- lm(form_A2, data = train)
predictionsA2VS <- predict(object = A2VS, newdata = test)

# Cálculo de errores
ErrorsA2VS <- predictionsA2VS - test$Log_Total_hour_salary

# Media y desviación estándar
Mean_errorsA2VS <- mean(ErrorsA2VS)
sd_errorsA2VS <- sd(ErrorsA2VS)

# Identificación de outliers
test <- test %>%
  mutate(error = ErrorsA2VS,
         sdA2VS = abs(error - Mean_errorsA2VS),
         outlier = if_else(sdA2VS > 2 * sd_errorsA2VS, 1, 0))

# DataFrame para graficar
df_errores <- data.frame(error = test$error)

# Gráfico de distribución
ggplot(df_errores, aes(x = error)) +
  geom_histogram(bins = 30, fill = "grey", color = "black", alpha = 0.7) +
  geom_vline(xintercept = Mean_errorsM2VS, color = "black", linetype = "dashed", size = 1) +
  geom_vline(xintercept = Mean_errorsM2VS + 2 * sd_errorsM2VS, color = "darkblue", linetype = "dashed", size = 1) +
  geom_vline(xintercept = Mean_errorsM2VS - 2 * sd_errorsM2VS, color = "darkblue", linetype = "dashed", size = 1) +
  labs(title = "Distribución del error de predicción",
       x = "Prediction Error",
       y = "-") +
  theme_minimal()

# Casos de outliers
Outliersdf <- test %>%
  filter(test$outlier==1)

outliers_vars <- c("y_ingLab_m", "relab", "totalHoursWorked", "age","sex","estrato1","edu_years","exp")
stargazer(as.data.frame(Outliersdf[, outliers_vars]), type = "latex")



# Gráfico de distribución Ing_Lab_m

ggplot(Outliersdf, aes(x = y_ingLab_m)) +
  geom_histogram(bins = 30, fill = "gray", color = "black", alpha = 0.7) +
  geom_vline(xintercept = mean(Outliersdf$y_ingLab_m), color = "darkblue", linetype = "dashed", size = 1) +
  labs(x = "Monthly Laboral Income",
       y = "-") +
  theme_minimal() +
  scale_x_continuous(labels = label_number(accuracy = 1))



```



```{r}

modelo_A1CV <- train(form_A1,
                   data = train,
                   method = "lm",
                   metric = "RMSE",
                   trControl = ctrl)

scoreCV_A1 <- mean(modelo_A1CV$resample$RMSE)

modelo_A2CV <- train(form_A2,
                    data = train,
                    method = "lm",
                    metric = "RMSE",
                    trControl = ctrl)

scoreCV_A2 <- mean(modelo_A2CV$resample$RMSE)


```

```{r}

scores_LOOCV <- c()

  set.seed(10101)   
  ctrl <- trainControl(method = "LOOCV")  ## Method
  
  # train the model
  LOOCVA1 <- train(form_A1,
                 data = db,
                 method = 'lm', 
                 trControl= ctrl)
  
  ## Save the RMSE
  scoreLOOCVA1 <-RMSE(LOOCVA1$pred$pred, db$Log_Total_hour_salary)
  scores_LOOCV<- append(scores_LOOCV, scoreLOOCVA1) 

  # train the model
  LOOCVA2 <- train(form_A2,
                 data = db,
                 method = 'lm', 
                 trControl= ctrl)
  
  ## Save the RMSE
  scoreLOOCVA2 <-RMSE(LOOCVA2$pred$pred, db$Log_Total_hour_salary)
  scores_LOOCV<- append(scores_LOOCV, scoreLOOCVA2) 
  
  
scores_LOOCV  


tabla_modelosloocv <- data.frame(
  Modelo = c("A1","A2"),
  RMSE_VS = c(score_modelo_A1, score_modelo_A2),
  RMSE_CV= c(scoreCV_A1,scoreCV_A2),
  RMSELOOCV= c(scoreLOOCVA1,scoreLOOCVA2))

# Ordena por desempeño en test (menor RMSE es mejor)
tabla_modelosloocv <- tabla_modelosloocv[order(tabla_modelosloocv$RMSELOOCV), ]
tabla_modelosloocv

```
