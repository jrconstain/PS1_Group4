---
title: "Age-wage profile"
author: "Jesús Yancy - Juan Otalora"
date: "2025-09-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Set working directory
username <- Sys.getenv("USER")

if (username == "jesusyancy"){
  path <- "/Users/jesusyancy/Documents/MECA/BDML/TALLERES/TALLER 1"
} else if(username == ''){
  path <- ""
}
setwd(path)
```

```{r}
library(pacman)
```

```{r}
# Instalar paquetes
p_load(rio, # import/export data
       tidyverse, # tidy-data
       skimr, # summary data
       visdat, # visualizing missing data
       corrplot, # Correlation Plots 
       stargazer) # tables/output to TEX.
```

```{r}
df <- read_csv("db_clean.csv")
```

## 3. Age-wage profile.

A great deal of evidence in labor economics suggests that the typical worker’s age-wage profile has a predictable path: “Wages tend to be low when the worker is young; they rise as the worker ages, peaking at about age 50; and the wage rate tends to remain stable or decline slightly after age 50”.

In this subsection we are going to estimate the Age-wage profile profile for the individuals in this sample:

$$ log(w) = β_1 + β_2Age+ β_3Age^2 + u $$

```{r}
df <- df %>%
  mutate(age2 = age^2)
```

```{r}
model_age <- lm(Log_Total_hour_salary ~ age + age2, data = df)

stargazer(model_age, type = "text")
```

### Interpretación

$\beta_2>0$ y $\beta_3<0$ confirman una trayectoria cóncava:$\partial\ln w/\partial \text{age}=\beta_2+2\beta_3\text{age}$ es positiva a edades tempranas y decrece con la edad.

La estimación del perfil edad–salario muestra un coeficiente positivo para la edad (0.065) y un coeficiente negativo para la edad al cuadrado (-0.001), ambos estadísticamente significativos al 1%. Esto implica que los salarios horarios aumentan con la edad, pero a un ritmo decreciente, confirmando la forma cóncava predicha por la teoría de capital humano.

### Ajuste en muestra 

El $R^2=0.039$ es esperable en este tipo de estimaciones: la variación no explicada suele residir en educación, ocupación, sector, horas y otros controles no modelados. Que el ajuste sea bajo no invalida el hallazgo central sobre la forma del perfil (Mincer, 1974).  


## Peak age

```{r}
# Extraer coeficientes
coefs <- coef(model_age)
b2 <- coefs["age"]
b3 <- coefs["age2"]

peak_age <- -b2 / (2 * b3)
peak_age

peak_salary <- coefs["(Intercept)"] + b2*peak_age + b3*peak_age^2
exp(peak_salary)

```

La edad que maximiza el salario esperado es

$age^*=-\frac{\hat\beta_2}{2\hat\beta_3}=\mathbf{45.33}\ \text{años}.$

Para la muestra original, la edad del máximo es 45.33 años y, a partir de un bootstrap no paramétrico con 1,000 réplicas, obtenemos sesgo ≈ 0.034, EE ≈ 0.699, e intervalo percentil 95% $[44.11,\ 46.83]$. Esto sitúa el pico de salario por hora de manera estadísticamente precisa en la segunda mitad de los 40s, coherente con la acumulación temprana de capital humano y retornos decrecientes conforme aumentan los años. La Figura x (perfil estimado) muestra la pendiente positiva inicial, el aplanamiento alrededor del pico y una ligera caída posterior, tal como documentan los perfiles edad–salario clásicos.  

```{r}
library(ggplot2)

# Coefs y pico
coefs <- coef(model_age)
b1 <- coefs["(Intercept)"]; b2 <- coefs["age"]; b3 <- coefs["age2"]

peak_age  <- -b2 / (2*b3)
peak_logw <- b1 + b2*peak_age + b3*peak_age^2
peak_salary_lvl <- exp(peak_logw)
peak_salary_lab <- format(peak_salary_lvl, big.mark = ",", decimal.mark = ".", scientific = FALSE, trim = TRUE)

# Edades
age_min <- 18
age_max <- ceiling(max(df$age, na.rm = TRUE))
age_seq <- seq(age_min, age_max, length.out = 400)
newdat  <- data.frame(age = age_seq, age2 = age_seq^2)

# Niveles
pred <- predict(model_age, newdata = newdat, se.fit = TRUE)
crit <- qnorm(0.975)

fit_lvl <- exp(pred$fit)
lwr_lvl <- exp(pred$fit - crit*pred$se.fit)
upr_lvl <- exp(pred$fit + crit*pred$se.fit)

plot_data <- data.frame(age = age_seq, fit = fit_lvl, lwr = lwr_lvl, upr = upr_lvl)
peak_point <- data.frame(age = peak_age, lvl = peak_salary_lvl)

# Gráfico
p <- ggplot(plot_data, aes(x = age, y = fit)) +
  geom_line(color = "black", linewidth = 1.0) +
  geom_vline(xintercept = peak_age, linetype = "dashed", color = "grey35", linewidth = 0.6) +
  geom_point(data = peak_point, aes(y = lvl),
             shape = 21, size = 2.8, stroke = 0.7, fill = "white", color = "black") +
  geom_label(
    data = peak_point,
    aes(y = lvl, label = sprintf("Edad: %.1f años\nSalario: %s", peak_age, peak_salary_lab)),
    nudge_x = 0.02*(age_max - age_min), nudge_y = 0.04*diff(range(plot_data$fit, na.rm = TRUE)),
    label.size = 0, fill = "white", size = 3.2, hjust = 0, vjust = 0.4
  ) +
  scale_x_continuous(limits = c(age_min, age_max), breaks = seq(18, age_max, by = 4)) +
  scale_y_continuous(expand = expansion(mult = c(0.02, 0.06))) +
  labs(
    title = "Perfil edad–salario estimado",
    x = "Edad (años)",
    y = "Salario por hora (niveles)"
  ) +
  theme_classic(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    axis.line  = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )

p
```

## Calcular los intervalos de confianza del peak age con bootstrap

```{r}
# Se define la función que recibe los datos y un vector de índices que boot genera en cada subset de la muestra con reemplazo.
# La función devuelve el peak age para cada subset.
peak_fn <- function(data, index) {
  fit <- lm(Log_Total_hour_salary ~ age + age2, data = data, subset = index) # Estima el modelo con cada subset
  coefs <- coef(fit)
  -coefs["age"] / (2 * coefs["age2"]) # Calcular el peak age de cada subset
}

# Se prueba en la muestra original
peak_fn(df, 1:nrow(df))

# bootstrap con 1000 réplicas
set.seed(123)
boot_out <- boot(df, statistic = peak_fn, R = 1000)

# resultados
boot_out$t0          # peak age de la muestra original
boot_out             # resumen del bootstrap

# intervalos de confianza
boot.ci(boot_out, type = "perc")
```

Nota metodológica (bootstrap). El intervalo se construyó con el método percentil, re-muestreando individuos con reemplazo, re-estimando $\hat age^$ en cada réplica y leyendo los cuantiles 2.5% y 97.5%.


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
